Так как в задании не указано какого типа числа хранятся в массиве, который необходимо отсортировать,
я решил  остановился на сортировке подсчётом, временная сложность которого равна O(n+k), где k=max(arr[]), 
при некоторых Но:
Но №1. В массиве хранятся элементы типа int.
Но №2. Заранее известен разброс элементов и он находится в промежутке (-4*size(); 4*size())
Но №3. Выделение O(max(arr[]) дополнительной памяти не является проблемой.
При этих условиях эта сортировка показывает наилучшее время.

Но если разброс элементов будет больше, то лучше становится быстрая сортировка. В ней, для выбора опорного элемента я 
использовал медиану первого, среднего и последнего элементов. Благодаря чему, уменьшается вероятность ухудшения времени алгоритма
до O(n^2). И если передать, упомянутый в задании, уже отсортированный массив, функция без проблем его отсортирует за O(nlog(n)).

Для измерения времени работы фукнции сортировки я написал класс Time.h.
Запустив Sort_test.exe можно увидить сравение времени работы этих двух сортировок на вашем компьютере.

Итог:
Если в массиве хранятся элементы типа int, заранее известен их разброс, который находится в промежутке (-4*size(); 4*size()),
и выделение O(max(arr[]) дополнительной памяти не является проблемой, то лучше остановиться на сортировке подсчетом.
В противном случае отдать предпочтение быстрой сортировке.
Ну и само собой если отсортировать нужно массив не типа int, то воспользоваться следует быстрой сортировкой.

